% Arquivo LaTeX de exemplo de monografia para a disciplina MAC0499
% 
% Adaptado em julho/2015 a partir do
%
% ---------------------------------------------------------------------------- %
% Arquivo LaTeX de exemplo de dissertação/tese a ser apresentados à CPG do IME-USP
%
% Versão 5: Sex Mar  9 18:05:40 BRT 2012
% 
% Criação: Jesús P. Mena-Chalco
% Revisão: Fabio Kon e Paulo Feofiloff


\documentclass[12pt,twoside,a4paper]{book}

% ---------------------------------------------------------------------------- %
% Pacotes 
\usepackage[T1]{fontenc}
\usepackage[brazilian]{babel}
\usepackage[latin1]{inputenc}
\usepackage[pdftex]{graphicx}           % usamos arquivos pdf/png como figuras
\usepackage{setspace}                   % espaçamento flexível
\usepackage{indentfirst}                % indentação do primeiro parágrafo
\usepackage{makeidx}                    % índice remissivo
\usepackage[nottoc]{tocbibind}          % acrescentamos a bibliografia/indice/conteudo no Table of Contents
\usepackage{type1cm}                    % fontes realmente escaláveis
\usepackage{listings}                   % para formatar código-fonte (ex. em Java)
\usepackage{titletoc}
%\usepackage[bf,small,compact]{titlesec} % cabeçalhos dos títulos: menores e compactos
\usepackage[fixlanguage]{babelbib}
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}
\usepackage[usenames,svgnames,dvipsnames]{xcolor}
\usepackage[a4paper,top=2.54cm,bottom=2.0cm,left=2.0cm,right=2.54cm]{geometry} % margens
%\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,colorlinks=true,citecolor=black,linkcolor=black,urlcolor=black,filecolor=black,bookmarksopen=true]{hyperref} % links em preto
\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,colorlinks=true,citecolor=DarkGreen,linkcolor=NavyBlue,urlcolor=DarkRed,filecolor=green,bookmarksopen=true]{hyperref} % links coloridos
\usepackage[all]{hypcap}                    % soluciona o problema com o hyperref e capitulos
\usepackage[round,sort,nonamebreak]{natbib} % citação bibliográfica textual(plainnat-ime.bst)
\usepackage{emptypage}  % para não colocar número de página em página vazia
\fontsize{60}{62}\usefont{OT1}{cmr}{m}{n}{\selectfont}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}    
\usepackage{algorithm}
\usepackage{algorithmic}
% ---------------------------------------------------------------------------- %
% Cabeçalhos similares ao TAOCP de Donald E. Knuth
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\chaptermark}[1]{\markboth{\MakeUppercase{#1}}{}}
\renewcommand{\sectionmark}[1]{\markright{\MakeUppercase{#1}}{}}
\renewcommand{\headrulewidth}{0pt}
% ---------------------------------------------------------------------------- %
% ---------------------------------------------------------------------------- %
\usepackage{listings}

% ---------------------------------------------------------------------------- %

\graphicspath{{./figuras/}}             % caminho das figuras (recomendável)
\frenchspacing                          % arruma o espaço: id est (i.e.) e exempli gratia (e.g.) 
\urlstyle{same}                         % URL com o mesmo estilo do texto e não mono-spaced
\makeindex                              % para o índice remissivo
\raggedbottom                           % para não permitir espaços extra no texto
\fontsize{60}{62}\usefont{OT1}{cmr}{m}{n}{\selectfont}
\cleardoublepage
\normalsize

% ---------------------------------------------------------------------------- %
 \definecolor{key}{RGB}{0,100,161}
 \definecolor{comment}{RGB}{100,107,110}
 \definecolor{number}{RGB}{60,60,60}
 \definecolor{id}{rgb}{0,0.28,0.45}
 \definecolor{param}{rgb}{0,0.19,0.32}
 \definecolor{functions}{rgb}{0,0.19,0.32}
 \definecolor{type}{RGB}{0,50,160}
\definecolor{text}{RGB}{20, 20, 20}

\lstset{
    % escapeinside={\$}{\$)},
    language=Python,
    morekeywords={do, nil, where},
    %morecomment=[l]{\#},
    basicstyle=\code\color{text},
    keywordstyle=\color{key},
    commentstyle=\color{comment},
    numberstyle=\color{number},
    basicstyle=\footnotesize,       % the size of the fonts that are used for the code
    numbers=left,                   % where to put the line-numbers
    numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
    stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
    numbersep=5pt,                  % how far the line-numbers are from the code
    showspaces=false,               % show spaces adding particular underscores
    showstringspaces=false,         % underline spaces within strings
    showtabs=false,                 % show tabs within strings adding particular underscores
    breaklines=true,
    frame=single,	                % adds a frame around the code
    framerule=0.6pt,
    tabsize=2,	                    % sets default tabsize to 2 spaces
    captionpos=b,                   % sets the caption-position to bottom
    breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
    escapeinside={\%*}{*)},         % if you want to add a comment within your code
    backgroundcolor=\color[rgb]{1.0,1.0,1.0}, % choose the background color.
    rulecolor=\color[rgb]{0.8,0.8,0.8},
    xleftmargin=15pt,
    xrightmargin=10pt,
    framexleftmargin=15pt,
    framexrightmargin=10pt,
    numbers=left,
    emph={[20]Int, Float, Bool, String, Double,None},
    emph={[30]true, false,def, self},
    emph={[40]rand, read, write, insert, append, push, pop, empty, and, or, not},
    emphstyle={[20]\color{orange}},
    emphstyle={[30]\color{key}},
    emphstyle={[40]\color{brown}},
    literate={á}{{\'a}}1 {ã}{{\~a}}1 {à}{{\`a}}1 {â}{{\^a}}1%
    {è}{{\`e}}1 {é}{{\'e}}1 {ê}{{\^e}}1%
    {í}{{\'i}}1%
    {ó}{{\'o}}1 {õ}{{\~o}}1 {ô}{{\^o}}1%
    {ú}{{\'u}}1%
    {ç}{{\,c}}1%
    {\$}{{\textcolor{blue}{\$}}}1,
}
\floatname{algorithm}{Algoritmo}
% ---------------------------------------------------------------------------- %
% Corpo do texto
\begin{document}

\frontmatter 
% cabeçalho para as páginas das seções anteriores ao capítulo 1 (frontmatter)
\fancyhead[RO]{{\footnotesize\rightmark}\hspace{2em}\thepage}
\setcounter{tocdepth}{2}
\fancyhead[LE]{\thepage\hspace{2em}\footnotesize{\leftmark}}
\fancyhead[RE,LO]{}
\fancyhead[RO]{{\footnotesize\rightmark}\hspace{2em}\thepage}

\onehalfspacing  % espaçamento
%\doublespacing

% ---------------------------------------------------------------------------- %
% CAPA
\thispagestyle{empty}
\begin{center}
    \vspace*{2.3cm}
    Universidade de São Paulo\\
    Instituto de Matemática e Estatística\\
    Bachalerado em Ciência da Computação


    \vspace*{3cm}
    \Large{Mateus Barros Rodrigues}
    

    \vspace{3cm}
    \textbf{\Large{Implementação de algoritmos para \\
        consultas de segmentos em janelas}}
    
       
    \vskip 5cm
    \normalsize{São Paulo}

    \normalsize{Setembro de 2016}
\end{center}

% ---------------------------------------------------------------------------- %
% Página de rosto
%
\newpage
\thispagestyle{empty}
    \begin{center}
        \vspace*{2.3 cm}
        \textbf{\Large{Implementação de algoritmos para \\
consultas de segmentos em janelas}}
        \vspace*{2 cm}
    \end{center}

    \vskip 2cm

    \begin{flushright}
	Monografia final da disciplina \\
        MAC0499 -- Trabalho de Formatura Supervisionado.
    \end{flushright}

    \vskip 5cm

    \begin{center}
    Supervisor: Prof. Dr. Carlos Eduardo Ferreira\\

    \vskip 5cm
    \normalsize{São Paulo}

    \normalsize{Setembro de 2016}
    \end{center}
\pagebreak




\pagenumbering{roman}     

%% % ---------------------------------------------------------------------------- %
%% % Agradecimentos:
%% % Se o candidato não quer fazer agradecimentos, deve simplesmente eliminar esta página 
%% \chapter*{Agradecimentos}
%% Texto texto texto texto texto texto texto texto texto texto texto texto texto
%% texto texto texto texto texto texto texto texto texto texto texto texto texto
%% texto texto texto texto texto texto texto texto texto texto texto texto texto
%% texto texto texto texto. Texto opcional.



% ---------------------------------------------------------------------------- %
% Resumo
\chapter*{Resumo}

Este trabalho de conclusão de curso fundamentou-se na compreensão e implementação em linguagem \emph{python} de um algoritmo para
consultas de intersecções de segmentos de retas com janelas retangulares no espaço, um subproblema de geometria computacional
conhecido por: buscas em regiões ortogonais. Este algoritmo foi o foco da tese de mestrado de Álvaro Junio Pereira Franco. Além da
implementação, foi feita também a adaptação do visualizador de algoritmos geométricos feito por Alexis Sakurai Landgraf para
exposição dos resultados obtidos.
\\

\noindent \textbf{Palavras-chave:} Geometria, janelas, segmentos, buscas. 

% ------------------------------------------------------------------------------- %
% Sumário
\tableofcontents    % imprime o sumário




%% % ---------------------------------------------------------------------------- %
%% \chapter{Lista de Abreviaturas}
%% \begin{tabular}{ll}
%%          CFT         & Transformada contínua de Fourier (\emph{Continuous Fourier Transform})\\
%%          DFT         & Transformada discreta de Fourier (\emph{Discrete Fourier Transform})\\
%%         EIIP         & Potencial de interação elétron-íon (\emph{Electron-Ion Interaction Potentials})\\
%%         STFT         & Tranformada de Fourier de tempo reduzido (\emph{Short-Time Fourier Transform})\\
%% \end{tabular}

%% % ---------------------------------------------------------------------------- %
%% \chapter{Lista de Símbolos}
%% \begin{tabular}{ll}
%%         $\omega$    & Frequência angular\\
%%         $\psi$      & Função de análise \emph{wavelet}\\
%%         $\Psi$      & Transformada de Fourier de $\psi$\\
%% \end{tabular}

%% % ---------------------------------------------------------------------------- %
%% % Listas de figuras e tabelas criadas automaticamente
%% \listoffigures            
%% \listoftables            



% ---------------------------------------------------------------------------- %
% Capítulos do trabalho
\mainmatter

% cabeçalho para as páginas de todos os capítulos
\fancyhead[RE,LO]{\thesection}

\singlespacing              % espaçamento simples
%\onehalfspacing            % espaçamento um e meio


%% ------------------------------------------------------------------------- %%
\chapter{Introdução}
\label{cap:introducao}

Neste trabalho de conclusão de curso foi abordado o problema de \emph{consultas de segmentos em janelas}, um problema de
\emph{buscas em intervalos ortogonais}, que é um dos tópicos fundamentais da área de geometria computacional.\par
Dado um conjunto $S$ de segmentos no espaço ( Seja no $\mathbb{R}\ ,\ \mathbb{R}^{2}$, etc. ) e uma janela W de lados paralelos,
queremos responder rapidamente a seguinte pergunta: \emph{quais segmentos de $S$ estão contidos na ou intersectam a janela W?}
\par
Este trabalho foi baseado em \emph{Consultas de segmentos em janelas: algoritmos e estruturas de dados} de \citet{junio09:MSc},
portanto seguiremos a mesma divisão do problema que foi proposta nessa dissertação: Encontrar pontos contidos em janelas e achar
todos os segmentos que intersectam com um dado segmento ( Horizontal ou vertical ). Seguiremos também a mesma divisão de
capítulos: Primeiramente apresentaremos definições e primitivas geométricas, dedicaremos um capítulo para falar de consultas de
pontos em janelas, um para falar de encontrar intersecção de segmentos e finalmente um onde agregaremos esses algoritmos para
resolver o problema proposto. Todo o código desenvolvido foi escrito em linguagem \emph{python} e está disponível no
\href{http://github.com/mlordx/MAC0499/}{gitHub}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%-
%-
%-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ------------------------------------------------------------------------- %%

%% ------------------------------------------------------------------------- %%
\chapter{Defini\c{c}\~oes e Primitivas}
\label{cap:definicoes}

Explicaremos a seguir algumas das noções fundamentais que serão utilizadas ao longo do trabalho:

\section{Pontos e Segmentos}
Neste trabalho trataremos basicamente com pontos e segmentos de reta no espaço~($\mathbb{R}~\text{e}~\mathbb{R}^2$). Sejam
$x,y \in \mathbb{R} $ definimos um \textbf{ponto} no $\mathbb{R}^2$ como um par $ p = (x,y) $. Um \textbf{segmento} $s$ pode ser
formalmente definido como o conjunto solução de $s = u + t*v,~ t \in [0,1],~ u,v$ pontos. Seremos um pouco relaxados quanto à isso
e os representaremos como um par de pontos e um reta por cima para dar destaque: $ s \coloneqq \overline{(x_1,y_1)(x_2,y_2)}$, onde
$u = (x_1,y_1)$ e $v = (x_2,y_2)$ são pontos chamados de \textbf{pontos extremos} de $s$.
\section{Comparações entre pontos}
\par
Uma outra definição que será usada copiosamente ao longo desta monografia é a relação de desigualdade associada à uma dada
coordenada. Sejam $u,v$ pontos, dizemos que $u \leq_x v $ caso $x(u) < x(v)$ ou $ x(u) = x(v)$ e $y(u) \leq y(v)$ ( Simetricamente
definido para desigualdades em relação à coordenada $y$), ou seja, sempre comparamos primeiro a coordenada de maior interesse e
desempatamos pela segunda coordenada nas comparações.

\section{Posição relativa entre ponto e segmento}

Usaremos também bastante a noção de posição relativa entre pontos e segmentos, isto é, dado um ponto $p$ e um segmento $s$,
queremos saber se $p$ se encontra \textbf{à esquerda}, \textbf{à direita} ou \textbf{sobre} o segmento $s$.\\

Sejam $p \coloneqq (x_1,y_1) \in \mathbb{R}^2$, $s \coloneqq \overline{(x_2,y_2)(x_3,y_3)}$ e 
\begin{math}
d \coloneqq \det{
\begin{pmatrix}
  x_1 && y_1 && 1 \\ 
  x_2 && y_2 && 1 \\
  x_3 && y_3 && 1 \\
\end{pmatrix}
}
\end{math}\newpage 

Dizemos que $p$ está \textbf{à esquerda} de $s$ caso $ d > 0 $, que está \textbf{sobre} $s$ caso $d = 0$ e que está \textbf{à
  direita} de $s$ caso contrário. Seguem a seguir os trechos de código que foram usados no trabalho para realizarmos essas
verificações:

\begin{algorithm}
\caption{Retorna \textbf{TRUE} caso $p$ esteja à esquerda de $s$.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def left(p,s):
    b = s.beg
    c = s.end
    if b.x == c.x and p.x == b.x: return p.y > c.y
    if b.y == c.y and p.y == b.y: return p.x < c.x
    return (b.x-p.x)*(c.y-p.y) - (b.y-p.y)*(c.x-p.x) > 0
\end{lstlisting}
\end{algorithm} 

\begin{algorithm}
\caption{Retorna \textbf{TRUE} caso $p$ esteja à direita de $s$.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def right(p,s):
    b = s.beg
    c = s.end
    if b.x == c.x and p.x == b.x: return p.y < b.y
    if b.y == c.y and p.y == b.y: return p.x > c.x
    return not(left_on(p,s)) 
\end{lstlisting}
\end{algorithm} 

\par Algumas ressalvas sobre essas funções: 
\begin{itemize}
\item[-] A única diferença da função \emph{left\_on} em relação à função \emph{left} é que ela também retorna \emph{true} caso o
  ponto esteja sobre o segmento dado.

\item[-] As modificações presentes nas linhas 4 e 5 foram adicionadas apenas para resolverem os casos degenerados apresentados no
  capítulo $x$.
\end{itemize}
%% ------------------------------------------------------------------------- %%

%% ------------------------------------------------------------------------- %%
\chapter{Consultas sobre pontos em janelas}
\label{cap:pontos}

Nesse capítulo mostraremos os algoritmos implementados para localizarmos todos os pontos numa dada janela e algumas variações
desse problema. Todas as provas de corretude e de eficiência dos algoritmos expostos, tanto deste capítulo quanto dos próximos,
poderão ser encontradas na dissertação de \citet{junio09:MSc}.

\section{Janela limitada - Caso unidimensional}

Analisaremos primeiramente o problema no espaço $\mathbb{R}$, ou seja, nossos pontos estarão todos contidos na reta. Sejam $u,v$
pontos na reta tais que $u \leq v$, definimos uma \textbf{janela} como sendo um \emph{intervalo fechado} com extremos $u$ e $v$.

\subsection{Pré-processamento}

Para resolvermos rapidamente sucessivas consultas sobre um dado conjunto de pontos, precisaremos armazenar esses dados em uma
estrutura de dados apropriada. A estrutura que usaremos será um tipo de \textbf{árvore de busca binária balanceada} ( ABBB ) chamada
de árvore limite, onde cada nó terá 3 campos: o ponto associado, um ponteiro para o filho esquerdo e um ponteiro para o filho
direito. A seguir está o trecho de código referente à construção da árvore:

\begin{algorithm}[H]
\caption{Retorna uma raíz $v$ de uma árvore limite 1D construída sobre um conjunto de pontos ordenados.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def buildTree(self,points):
    v = Node(None)
    l = points[:len(points)//2]
    r = points[len(points)//2:]

    v.point = points[len(points)//2-1]
        
    if len(points) == 1:
        v.l = v.r = None
    else:
        v.l = self.buildTree(l)
        v.r = self.buildTree(r)
    return v
\end{lstlisting}
\end{algorithm} 

\subsection{Realizando a consulta}

Seja $P$ um conjunto de pontos e seja $W = [w_1,w_2]$ uma janela. Podemos consultar todos os pontos de $P \subset W$ da seguinte forma:

\begin{itemize}
\item[1.] Construímos a ABBB sobre o conjunto $P$.
\item[2.] Achamos o \textbf{ponto divisor} de $P$, este é o ponto que se encontra na raiz da subárvore que contém os pontos
  $S \coloneqq $ ($v~|~w_1 \leq v \leq w_2 $), chamaremos esse ponto de $v_{div}$.
\item[3.] Percorremos a subàrvore esquerda de $v_{div}$ verificando se o ponto $r$ da raiz é tal que $w_1 \leq r$, caso seja,
  adicionamos todos os pontos dessa subàrvore na resposta e nos movemos para a subàrvore esquerda, caso contrário vamos para a
  subárvore direita. Ao chegar na folha apenas verificamos se $w_1 \leq r \leq w_2$ e adicionamos na resposta caso seja verdade.
\item[4.] Percorremos a subárvore direita de $v_{div}$ de forma simétrica ao item 3.
\end{itemize}

Segue a implementação das rotinas supracitadas juntamente com suas funções auxiliares:

\begin{algorithm}
\caption{Retorna \emph{true} caso $ w_1 \leq_x p \leq_x w_2 $}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def inRange(self,rng,p):
    w1,w2 = rng
    return w1 <= p and p <= w2
\end{lstlisting}
\end{algorithm} 
\begin{algorithm}
\caption{Retorna o ponto divisor $v_{div}$ de uma ABBB referente à uma dada janela \emph{rng}.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def findDividingNode(self,rng):
    w1,w2 = rng
    div = self.root

    while(not div.isLeaf() and (w1 > div.point or w2 <= div.point)):
        if w2 <= div.point:
            div = div.l
        else:
            div = div.r
    return div
\end{lstlisting}
\end{algorithm} 
\begin{algorithm}
\caption{Devolve uma lista com as folhas de uma dada árvore.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def listSubTree(self):
    l = []
    self.findLeaves(l)
    return l

def findLeaves(self,l):
    if self.isLeaf():
        l.append(self.point)
        
    if self.l is not None: self.l.findLeaves(l)
    if self.r is not None: self.r.findLeaves(l)
\end{lstlisting}
\end{algorithm} 

\begin{algorithm}
\caption{Retorna uma lista com todos os pontos contidos numa dada janela \emph{rng}.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def query(self,rng):
    div = self.findDividingNode(rng)
    p = []
        
    if div.isLeaf():
        if self.inRange(rng,div.point):
            p.append(div.point)
    else:
         v = div.l
         while(not v.isLeaf()):
             if w1 <= v.point:
                 subtree = v.r.listSubTree()
                 p += subtree
                 v = v.l
             else:
                 v = v.r
                    
         if self.inRange(rng,v.point):
             p.append(v.point)
                
         v = div.r
            
         while(not v.isLeaf()):
             if w2 > v.point:
                 subtree = v.l.listSubTree()
                 p += subtree
                 v = v.r
             else:
                 v = v.l
         if self.inRange(rng,v.point):
             p.append(v.point)

     return p
\end{lstlisting}
\end{algorithm} 
\newpage
\subsection{Análise}

\begin{itemize}
\item[-] O pré-processamento requer que seja feita uma ordenação sobre o conjunto de pontos de entrada, portanto tem complexidade
  $\Theta(n\log n)$.
\item[-] A árvore terá altura $\mathcal{O}(\log n)$ e visitaremos $\mathcal{O}(\log n)$ pontos em cada subàrvore de $v_{div}$,
  além disso, consumiremos tempo $\mathcal{O}(k)$ para visitar os $k$ pontos das folhas que estão contidos no intervalo e devem
  aparecer na resposta final. Portanto a complexidade final da consulta é da ordem $\mathcal{O}(n\log n + k)$.
\end{itemize}

\section{Janela limitada - Caso bidimensional}

Analisaremos agora o problema no espaço do $\mathbb{R}^2$. Sejam $w_1 = (x_1,y_1)$ e $w_2 = (x_2,y_2)$ pontos no $\mathbb{R}^2$,
os segmentos de reta que formam um retângulo de lados paralelos ao eixos e que passam pelos pontos $w_1$ e $w_2$ são:
$s_1 = \overline{(x_1,y_1)(x_1,y_2)},~s_2 = \overline{(x_1,y_2)(x_2,y_2)},~s_3 = \overline{(x_2,y_2)(x_2,y_1)}~\text{e}~s_4 =
\overline{(x_2,y_1)(x_1,y_1)}$, uma \textbf{janela} será definida como a intersecção desses 4 segmentos e sua região interna,
porém, usaremos uma representação compacta representando a janela pelo segmento $s = \overline{w_1,w_2}$. Mostraremos primeiro o
algoritmo mais simples que estende a ideia apresentada no algoritmo anterior e então mostraremos o algoritmo para consultas com
janelas limitadas bidimensionais mais eficiente.

\subsection{Pré-processamento}

Precisaremos de uma estrutura de dados que consiga particionar o espaço de tal forma que consigamos saber a ordem entre os pontos
em cada semiplano. Uma estrutura que nos fornece isso é a chamada \textbf{kd-tree} ( \emph{k-dimensional tree} ). A kd-tree é uma
ABBB cuja ordem dos elementos é feita sobre a coordenada $x$ e cada nó terá 4 elementos: uma raíz para uma ABBB cujos elementos
são os mesmos da subárvore do nó, mas os elementos estão ordenados pela coordenada $y$, um ponto, um ponteiro para o filho
esquerdo e um ponteiro para o filho direito.

Segue o algoritmo de construção dessa árvore. Omitiremos a implementação da estrutura auxiliar \emph{VerticalTree} cuja
descrição está presente no trabalho de \citet{junio09:MSc}, essa estrutura é uma ABBB construída sobre um \emph{heap} e tem tempo
de construção $\mathcal{O}(n)$.

\begin{algorithm}[H]
  \caption{Retorna uma raiz $v$ para uma ABBB ordenada pela coordenada
    $x$ a partir de um vetor de pontos ordenados por $x$ e um vetor de
    pontos ordenados por $y$.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def buildTree(self,vx,vy):
    v = Node(None)
    v.tree = VerticalTree(vy)
    lx = vx[:len(vx)//2]
    rx = vx[len(vx)//2:]
    n = len(vx)
    ly = []
    ry = []
        
    for i in range(n):
        if vy[i].x < vx[n//2-1].x or (vy[i].x == vx[n//2-1].x and vy[i].y <= vx[n//2-1].y):
            ly.append(vy[i])
        else: ry.append(vy[i])
        
    v.point = vx[n//2-1]
        
    if len(vx) == 1:
        v.l = v.r = None
    else:
        v.l = self.buildTree(lx,ly)
        v.r = self.buildTree(rx,ry)

    return v
\end{lstlisting}
\end{algorithm}

\subsection{Realizando a consulta}
Seja $P$ um conjunto de pontos e seja $W = \overline{(x_1,y_1)(x_2,y_2)}$ uma janela. Podemos consultar todos os pontos de $P \subset W$ da seguinte forma:

\begin{itemize}
\item[1.] Construímos a kd-tree sobre o conjunto $P$.
\item[2.] Achamos o \textbf{ponto divisor} no primeiro nível da kd-tree de forma similar ao algoritmo anterior.
\item[3.] Percorremos a subàrvore esquerda de $v_{div}$ verificando se o ponto $r$ da raiz é tal que $w_1 \leq_{x} r$, caso seja,
  realizamos a consulta unidimensional na árvore associada ao nó. Caso contrário, caso contrário vamos para a subárvore
  direita. Ao chegar na folha apenas verificamos se $w_1 \leq_{x} r \leq_{x} w_2$ e adicionamos na resposta caso seja verdade.
\item[4.] Percorremos a subárvore direita de $v_{div}$ de forma simétrica ao item 3.
\end{itemize}

Segue a implementação das rotinas supracitadas juntamente com suas funções auxiliares:

\begin{algorithm}[H]
\caption{Verifica se o ponto $p$ está contido na janela \emph{rng}.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def inRange(self,rng,p):
    w1,w2 = rng
    a = w1.x < p.x or (w1.x == p.x and w1.y <= p.y)
    b = p.x < w2.x or (p.x == w2.x and p.y <= w2.y)
    c = w1.y < p.y or (w1.y == p.y and w1.x <= p.x)
    d = p.y < w2.y or (p.y == w2.y and p.x <= w2.x)
    return a and b and c and d
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[H]
  \caption{Retorna uma lista com todos os pontos contidos numa dada janela \emph{rng}.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def query(self,rng):
    p = []
    w1,w2 = rng
    div = self.findDividingNode(rng)

    if div.isLeaf():
        if self.inRange(rng,div.point):
            p.append(div.point)
    else:
        v = div.l

        while not v.isLeaf():
            if w1.x < v.point.x or (w1.x == v.point.x and w1.y <= v.point.y):
                p += v.r.tree.oneDimQuery(rng)
                v = v.l
            else:
                v = v.r

        if self.inRange(rng,v.point): p.append(v.point)

        v = div.r

        while not v.isLeaf():
            if w2.x > v.point.x:
                p += v.l.tree.oneDimQuery(rng)
                v = v.r
            else:
                v = v.l

        if self.inRange(rng,v.point): p.append(v.point)
                
    return p
\end{lstlisting}
\end{algorithm}

\subsection{Análise}
\begin{itemize}
\item[-] No pré-processamento ordenamos 2 vezes o conjunto de pontos, levando tempo $\mathcal{O}(n \log n)$. A construção em si da
  primeira árvore leva tempo $\mathcal{O}(n \log n)$ e para cada um dos $\mathcal{O}(\log n)$ nós dela construímos uma estrutura
  auxiliar consumindo tempo $\mathcal{O}(n)$. O que nos leva ao consumo total de $\mathcal{O}(n \log n )$.
\item[-] Os caminhos esquerdo e direito a partir de $v_{div}$ têm $\mathcal{O}(\log n)$ nós, e possivelmente chamamos o algoritmo
  anterior para cada um deles, o que consome tempo $\mathcal{O}(\log n + k)$. O que nos leva ao consumo total de tempo de
  $\mathcal{O}(\log^2 n + k)$.
\end{itemize}

%% ------------------------------------------------------------------------- %%

\input cap-conclusoes

% cabeçalho para os apêndices
\renewcommand{\chaptermark}[1]{\markboth{\MakeUppercase{\appendixname\ \thechapter}} {\MakeUppercase{#1}} }
\fancyhead[RE,LO]{}
%\appendix

%\include{ape-exemplo}      % associado ao arquivo: 'ape-conjuntos.tex'


% ---------------------------------------------------------------------------- %
% Bibliografia
\backmatter \singlespacing   % espaçamento simples
\bibliographystyle{plainnat-ime} % citação bibliográfica textual
\bibliography{bibliografia}  % associado ao arquivo: 'bibliografia.bib'


%%%  ---------------------------------------------------------------------------- %
%% % Índice remissivo
%% \index{TBP|see{periodicidade região codificante}}
%% \index{DSP|see{processamento digital de sinais}}
%% \index{STFT|see{transformada de Fourier de tempo reduzido}}
%% \index{DFT|see{transformada discreta de Fourier}}
%% \index{Fourier!transformada|see{transformada de Fourier}}

%% \printindex   % imprime o índice remissivo no documento 

\end{document}
