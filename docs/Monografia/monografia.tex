% Arquivo LaTeX de exemplo de monografia para a disciplina MAC0499
% 
% Adaptado em julho/2015 a partir do
%
% ---------------------------------------------------------------------------- %
% Arquivo LaTeX de exemplo de dissertação/tese a ser apresentados à CPG do IME-USP
%
% Versão 5: Sex Mar  9 18:05:40 BRT 2012
% 
% Criação: Jesús P. Mena-Chalco
% Revisão: Fabio Kon e Paulo Feofiloff


\documentclass[12pt,twoside,a4paper]{book}

% ---------------------------------------------------------------------------- %
% Pacotes 
\usepackage[T1]{fontenc}
\usepackage[brazilian]{babel}
\usepackage[latin1]{inputenc}
\usepackage[pdftex]{graphicx}           % usamos arquivos pdf/png como figuras
\usepackage{setspace}                   % espaçamento flexível
\usepackage{indentfirst}                % indentação do primeiro parágrafo
\usepackage{makeidx}                    % índice remissivo
\usepackage[nottoc]{tocbibind}          % acrescentamos a bibliografia/indice/conteudo no Table of Contents
\usepackage{type1cm}                    % fontes realmente escaláveis
\usepackage{listings}                   % para formatar código-fonte (ex. em Java)
\usepackage{titletoc}
%\usepackage[bf,small,compact]{titlesec} % cabeçalhos dos títulos: menores e compactos
\usepackage[fixlanguage]{babelbib}
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}
\usepackage[usenames,svgnames,dvipsnames]{xcolor}
\usepackage[a4paper,top=2.54cm,bottom=2.0cm,left=2.0cm,right=2.54cm]{geometry} % margens
%\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,colorlinks=true,citecolor=black,linkcolor=black,urlcolor=black,filecolor=black,bookmarksopen=true]{hyperref} % links em preto
\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,colorlinks=true,citecolor=DarkGreen,linkcolor=NavyBlue,urlcolor=DarkRed,filecolor=green,bookmarksopen=true]{hyperref} % links coloridos
\usepackage[all]{hypcap}                    % soluciona o problema com o hyperref e capitulos
\usepackage[round,sort,nonamebreak]{natbib} % citação bibliográfica textual(plainnat-ime.bst)
\usepackage{emptypage}  % para não colocar número de página em página vazia
\fontsize{60}{62}\usefont{OT1}{cmr}{m}{n}{\selectfont}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}    
\usepackage{algorithm}
\usepackage{algorithmic}
% ---------------------------------------------------------------------------- %
% Cabeçalhos similares ao TAOCP de Donald E. Knuth
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\chaptermark}[1]{\markboth{\MakeUppercase{#1}}{}}
\renewcommand{\sectionmark}[1]{\markright{\MakeUppercase{#1}}{}}
\renewcommand{\headrulewidth}{0pt}
% ---------------------------------------------------------------------------- %
% ---------------------------------------------------------------------------- %
\usepackage{listings}

% ---------------------------------------------------------------------------- %

\graphicspath{{./figuras/}}             % caminho das figuras (recomendável)
\frenchspacing                          % arruma o espaço: id est (i.e.) e exempli gratia (e.g.) 
\urlstyle{same}                         % URL com o mesmo estilo do texto e não mono-spaced
\makeindex                              % para o índice remissivo
\raggedbottom                           % para não permitir espaços extra no texto
\fontsize{60}{62}\usefont{OT1}{cmr}{m}{n}{\selectfont}
\cleardoublepage
\normalsize

% ---------------------------------------------------------------------------- %
 \definecolor{key}{RGB}{0,100,161}
 \definecolor{comment}{RGB}{100,107,110}
 \definecolor{number}{RGB}{60,60,60}
 \definecolor{id}{rgb}{0,0.28,0.45}
 \definecolor{param}{rgb}{0,0.19,0.32}
 \definecolor{functions}{rgb}{0,0.19,0.32}
 \definecolor{type}{RGB}{0,50,160}
\definecolor{text}{RGB}{20, 20, 20}

\lstset{
    % escapeinside={\$}{\$)},
    language=Python,
    morekeywords={do, nil, where},
    %morecomment=[l]{\#},
    basicstyle=\code\color{text},
    keywordstyle=\color{key},
    commentstyle=\color{comment},
    numberstyle=\color{number},
    basicstyle=\footnotesize,       % the size of the fonts that are used for the code
    numbers=left,                   % where to put the line-numbers
    numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
    stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
    numbersep=5pt,                  % how far the line-numbers are from the code
    showspaces=false,               % show spaces adding particular underscores
    showstringspaces=false,         % underline spaces within strings
    showtabs=false,                 % show tabs within strings adding particular underscores
    breaklines=true,
    frame=single,	                % adds a frame around the code
    framerule=0.6pt,
    tabsize=2,	                    % sets default tabsize to 2 spaces
    captionpos=b,                   % sets the caption-position to bottom
    breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
    escapeinside={\%*}{*)},         % if you want to add a comment within your code
    backgroundcolor=\color[rgb]{1.0,1.0,1.0}, % choose the background color.
    rulecolor=\color[rgb]{0.8,0.8,0.8},
    xleftmargin=15pt,
    xrightmargin=5pt,
    framexleftmargin=15pt,
    framexrightmargin=10pt,
    numbers=left,
    emph={[20]Int, Float, Bool, String, Double,None},
    emph={[30]true, false,def, self},
    emph={[40]rand, read, write, insert, append, push, pop, empty, and, or, not},
    emphstyle={[20]\color{orange}},
    emphstyle={[30]\color{key}},
    emphstyle={[40]\color{brown}},
    literate={á}{{\'a}}1 {ã}{{\~a}}1 {à}{{\`a}}1 {â}{{\^a}}1%
    {è}{{\`e}}1 {é}{{\'e}}1 {ê}{{\^e}}1%
    {í}{{\'i}}1%
    {ó}{{\'o}}1 {õ}{{\~o}}1 {ô}{{\^o}}1%
    {ú}{{\'u}}1%
    {ç}{{\,c}}1%
    {\$}{{\textcolor{blue}{\$}}}1,
}
\floatname{algorithm}{Algoritmo}
% ---------------------------------------------------------------------------- %
% Corpo do texto
\begin{document}

\frontmatter 
% cabeçalho para as páginas das seções anteriores ao capítulo 1 (frontmatter)
\fancyhead[RO]{{\footnotesize\rightmark}\hspace{2em}\thepage}
\setcounter{tocdepth}{2}
\fancyhead[LE]{\thepage\hspace{2em}\footnotesize{\leftmark}}
\fancyhead[RE,LO]{}
\fancyhead[RO]{{\footnotesize\rightmark}\hspace{2em}\thepage}

\onehalfspacing  % espaçamento
%\doublespacing

% ---------------------------------------------------------------------------- %
% CAPA
\thispagestyle{empty}
\begin{center}
    \vspace*{2.3cm}
    Universidade de São Paulo\\
    Instituto de Matemática e Estatística\\
    Bachalerado em Ciência da Computação


    \vspace*{3cm}
    \Large{Mateus Barros Rodrigues}
    

    \vspace{3cm}
    \textbf{\Large{Implementação de algoritmos para \\
        consultas de segmentos em janelas}}
    
       
    \vskip 5cm
    \normalsize{São Paulo}

    \normalsize{Setembro de 2016}
\end{center}

% ---------------------------------------------------------------------------- %
% Página de rosto
%
\newpage
\thispagestyle{empty}
    \begin{center}
        \vspace*{2.3 cm}
        \textbf{\Large{Implementação de algoritmos para \\
consultas de segmentos em janelas}}
        \vspace*{2 cm}
    \end{center}

    \vskip 2cm

    \begin{flushright}
	Monografia final da disciplina \\
        MAC0499 -- Trabalho de Formatura Supervisionado.
    \end{flushright}

    \vskip 5cm

    \begin{center}
    Supervisor: Prof. Dr. Carlos Eduardo Ferreira\\

    \vskip 5cm
    \normalsize{São Paulo}

    \normalsize{Setembro de 2016}
    \end{center}
\pagebreak




\pagenumbering{roman}     

%% % ---------------------------------------------------------------------------- %
%% % Agradecimentos:
%% % Se o candidato não quer fazer agradecimentos, deve simplesmente eliminar esta página 
%% \chapter*{Agradecimentos}
%% Texto texto texto texto texto texto texto texto texto texto texto texto texto
%% texto texto texto texto texto texto texto texto texto texto texto texto texto
%% texto texto texto texto texto texto texto texto texto texto texto texto texto
%% texto texto texto texto. Texto opcional.



% ---------------------------------------------------------------------------- %
% Resumo
\chapter*{Resumo}

Este trabalho de conclusão de curso fundamentou-se na compreensão e implementação em linguagem \emph{python} de um algoritmo para
consultas de intersecções de segmentos de retas com janelas retangulares no espaço, um subproblema de geometria computacional
conhecido por: buscas em regiões ortogonais. Este algoritmo foi o foco da tese de mestrado de Álvaro Junio Pereira Franco. Além da
implementação, foi feita também a adaptação do visualizador de algoritmos geométricos feito por Alexis Sakurai Landgraf para
exposição dos resultados obtidos.
\\

\noindent \textbf{Palavras-chave:} Geometria, janelas, segmentos, buscas. 

% ------------------------------------------------------------------------------- %
% Sumário
\tableofcontents    % imprime o sumário




%% % ---------------------------------------------------------------------------- %
%% \chapter{Lista de Abreviaturas}
%% \begin{tabular}{ll}
%%          CFT         & Transformada contínua de Fourier (\emph{Continuous Fourier Transform})\\
%%          DFT         & Transformada discreta de Fourier (\emph{Discrete Fourier Transform})\\
%%         EIIP         & Potencial de interação elétron-íon (\emph{Electron-Ion Interaction Potentials})\\
%%         STFT         & Tranformada de Fourier de tempo reduzido (\emph{Short-Time Fourier Transform})\\
%% \end{tabular}

%% % ---------------------------------------------------------------------------- %
%% \chapter{Lista de Símbolos}
%% \begin{tabular}{ll}
%%         $\omega$    & Frequência angular\\
%%         $\psi$      & Função de análise \emph{wavelet}\\
%%         $\Psi$      & Transformada de Fourier de $\psi$\\
%% \end{tabular}

%% % ---------------------------------------------------------------------------- %
%% % Listas de figuras e tabelas criadas automaticamente
%% \listoffigures            
%% \listoftables            



% ---------------------------------------------------------------------------- %
% Capítulos do trabalho
\mainmatter

% cabeçalho para as páginas de todos os capítulos
\fancyhead[RE,LO]{\thesection}

\singlespacing              % espaçamento simples
%\onehalfspacing            % espaçamento um e meio

\newcommand{\setalglineno}[1]{%
  \setcounter{ALC@line}{\numexpr#1-1}}


%% ------------------------------------------------------------------------- %%
\chapter{Introdução}
\label{cap:introducao}

Neste trabalho de conclusão de curso foi abordado o problema de \emph{consultas de segmentos em janelas}, um problema de
\emph{buscas em intervalos ortogonais}, que é um dos tópicos fundamentais da área de geometria computacional.\par
Dado um conjunto $S$ de segmentos no espaço (Seja no $\mathbb{R}\ ,\ \mathbb{R}^{2}$, etc.) e uma janela W de lados paralelos,
queremos responder rapidamente a seguinte pergunta: \emph{quais segmentos de $S$ estão contidos na ou intersectam a janela W?}
\par
Este trabalho foi baseado em \emph{Consultas de segmentos em janelas: algoritmos e estruturas de dados} de \citet{junio09:MSc},
portanto seguiremos a mesma divisão do problema que foi proposta nessa dissertação: Encontrar pontos contidos em janelas e achar
todos os segmentos que intersectam com um dado segmento (Horizontal ou vertical). Seguiremos também a mesma divisão de capítulos:
Primeiramente apresentaremos definições e primitivas geométricas, dedicaremos um capítulo para falar de consultas de pontos em
janelas, um para falar de encontrar intersecção de segmentos e finalmente um onde agregaremos esses algoritmos para resolver o
problema proposto. Todo o código desenvolvido foi escrito em linguagem \emph{python} e está disponível no
\href{http://github.com/mlordx/MAC0499/}{gitHub}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%-
%-
%-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ------------------------------------------------------------------------- %%

%% ------------------------------------------------------------------------- %%
\chapter{Defini\c{c}\~oes e Primitivas}
\label{cap:definicoes}

Explicaremos a seguir algumas das noções fundamentais que serão utilizadas ao longo do trabalho:

\section{Pontos e segmentos}
Neste trabalho trataremos basicamente com pontos~(no $\mathbb{R}~\text{e}~\mathbb{R}^2$) e segmentos de reta~(restritos ao $\mathbb{R}^2$). Sejam $x,y
\in \mathbb{R} $ definimos um \textbf{ponto} no $\mathbb{R}^2$ como um par $ p = (x,y) $. Um \textbf{segmento} (definido pelos pontos $u,v \in
\mathbb{R}^2$) é o conjunto~$\{p \in \mathbb{R}^2 \colon p = u + t*v~\text{para algum}~t \in [0,1]\} \subseteq \mathbb{R}^2$. Seremos um pouco
relaxados quanto a isso e os representaremos como um par de pontos e um reta por cima para dar destaque: $ s \coloneqq \overline{(x_1,y_1)(x_2,y_2)}$,
onde $u = (x_1,y_1)$ e $v = (x_2,y_2)$ são pontos chamados de \textbf{pontos extremos} de $s$. Seja $p$ um ponto, diremos que $p \in
\overline{p_1,p_2}$ caso $p$ seja uma combinação afim de $p_1$ e $p_2$.

\section{Comparações entre pontos}
\par
Uma outra definição que será usada repetidamente ao longo desta monografia é a relação de desigualdade associada a uma dada
coordenada. Sejam $u,v$ pontos, dizemos que $u \leq_x v $ caso $x(u) < x(v)$ ou $ x(u) = x(v)$ e $y(u) \leq y(v)$, ou seja, sempre
comparamos primeiro a coordenada de maior interesse e desempatamos pela segunda coordenada nas comparações. Quando tivermos pontos
ordenados pela ordem $\leq_x$ diremos que estes pontos estão ordenados \textbf{sobre a coordenada \emph{x}}. Todas essas definições são
simétricas para a ordem $\leq_y$.

\section{Posição relativa entre ponto e segmento}

Usaremos também bastante a noção de posição relativa entre pontos e segmentos, isto é, dado um ponto $p$ e um segmento $s$,
queremos saber se $p$ se encontra à esquerda, à direita ou sobre o segmento $s$.\\

\noindent Sejam $p \coloneqq (x_1,y_1) \in \mathbb{R}^2$, $s \coloneqq \overline{(x_2,y_2)(x_3,y_3)}$ e 
\begin{math}
d \coloneqq \det{
\begin{pmatrix}
  x_1 && y_1 && 1 \\ 
  x_2 && y_2 && 1 \\
  x_3 && y_3 && 1 \\
\end{pmatrix}
}
\end{math}\newpage 

\noindent Dizemos que $p$ está \textbf{à esquerda} de $s$ caso $ d > 0 $, que está \textbf{sobre} $s$ caso $d = 0$ e que está
\textbf{à direita} de $s$ caso contrário. Seguem os trechos de código que foram usados no trabalho para realizarmos essas
verificações:

\begin{algorithm}
\caption{Retorna \textbf{TRUE} caso $p$ esteja à esquerda de $s$.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def left(p,s):
    b = s.beg
    c = s.end
    if b.x == c.x and p.x == b.x: return p.y > c.y
    if b.y == c.y and p.y == b.y: return p.x < c.x
    return (b.x-p.x)*(c.y-p.y) - (b.y-p.y)*(c.x-p.x) > 0
\end{lstlisting}
\end{algorithm} 

\begin{algorithm}
\caption{Retorna \textbf{TRUE} caso $p$ esteja à direita de $s$.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def right(p,s):
    b = s.beg
    c = s.end
    if b.x == c.x and p.x == b.x: return p.y < b.y
    if b.y == c.y and p.y == b.y: return p.x > c.x
    return not(left_on(p,s)) 
\end{lstlisting}
\end{algorithm} 

\par Algumas ressalvas sobre essas funções: 
\begin{itemize}
\item[-] A única diferença da função \emph{left\_on} em relação à função \emph{left} é que ela também retorna \emph{true} caso o
  ponto esteja sobre o segmento dado.

\item[-] As modificações presentes nas linhas 4 e 5 foram adicionadas apenas para resolverem os casos degenerados apresentados no
  capítulo $x$.
\end{itemize}
%% ------------------------------------------------------------------------- %%

%% ------------------------------------------------------------------------- %%
\chapter{Consultas sobre pontos em janelas}
\label{cap:pontos}

Nesse capítulo mostraremos os algoritmos implementados para localizarmos todos os pontos numa dada janela e algumas variações
desse problema. Todas as provas de corretude e de eficiência dos algoritmos expostos, tanto deste capítulo quanto dos próximos,
poderão ser encontradas na dissertação de \citet{junio09:MSc}.

\section{Janela limitada - Caso unidimensional}
\label{janela1d}
Analisaremos primeiramente o problema no espaço $\mathbb{R}$, ou seja, nossos pontos estarão todos contidos na reta. Sejam $u,v$
pontos na reta tais que $u \leq v$, definimos uma \textbf{janela} como sendo um \emph{intervalo fechado} com extremos $u$ e $v$.

\subsection{Pré-processamento}

Para resolvermos rapidamente sucessivas consultas sobre um dado conjunto de pontos, precisaremos armazenar esses dados em uma
estrutura de dados apropriada. A estrutura que usaremos será um tipo de árvore de busca binária balanceada (ABBB) chamada de
\textbf{árvore limite}, onde cada nó terá 3 campos: um ponteiro para um ponto associado, um ponteiro para o filho esquerdo e um
ponteiro para o filho direito. O balanceamento da árvore virá da sua construção, onde subdividimos o vetor de pontos ordenados e
colocamos um ponteiro para o ponto central na raíz, conseguimos assim altura $\mathcal{O}(\log n)$. A seguir está o trecho de
código referente à construção dessa árvore:

\begin{algorithm}[H]
\caption{Retorna uma raíz $v$ de uma árvore limite 1D construída sobre um conjunto de pontos ordenados.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def buildTree(self,points):
    v = Node(None)
    l = points[:len(points)//2]
    r = points[len(points)//2:]

    v.point = points[len(points)//2-1]
        
    if len(points) == 1:
        v.l = v.r = None
    else:
        v.l = self.buildTree(l)
        v.r = self.buildTree(r)
    return v
\end{lstlisting}
\end{algorithm} 

\subsection{Realizando a consulta}

Seja $P$ um conjunto de pontos e seja $W = [w_1,w_2]$ uma janela. Podemos consultar todos os pontos em $P \cap W$ da seguinte forma:

\begin{itemize}
\item[1.] Construímos a ABBB sobre o conjunto $P$.
\item[2.] Achamos o \textbf{ponto divisor} de $P$, este é o ponto que se encontra na raiz da subárvore que contém os pontos
  $S \coloneqq $ ($v~\colon~w_1 \leq v \leq w_2 $), chamaremos esse ponto de $v_{div}$.
\item[3.] Percorremos a subárvore esquerda de $v_{div}$ verificando se o ponto $r$ da raiz é tal que $w_1 \leq r$, caso seja,
  adicionamos todos os pontos dessa subárvore na resposta e nos movemos para a subárvore esquerda, caso contrário vamos para a
  subárvore direita. Ao chegar na folha apenas verificamos se $w_1 \leq r \leq w_2$ e adicionamos na resposta caso seja verdade.
\item[4.] Percorremos a subárvore direita de $v_{div}$ de forma simétrica ao item 3.
\end{itemize}

Segue a implementação das rotinas supracitadas juntamente com suas funções auxiliares:

\begin{algorithm}[H]
\caption{Retorna \emph{true} caso $ w_1 \leq p \leq w_2 $}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def inRange(self,rng,p):
    w1,w2 = rng
    return w1 <= p and p <= w2
\end{lstlisting}
\end{algorithm} 
\begin{algorithm}[H]
\caption{Retorna o ponto divisor $v_{div}$ de uma ABBB referente a uma dada janela \emph{rng}.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def findDividingNode(self,rng):
    w1,w2 = rng
    div = self.root

    while(not div.isLeaf() and
    (w1 > div.point or w2 <= div.point)):
        if w2 <= div.point:
            div = div.l
        else:
            div = div.r
    return div
\end{lstlisting}
\end{algorithm} 
\begin{algorithm}[H]
\caption{Devolve uma lista com as folhas de uma dada árvore.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def listSubTree(self):
    l = []
    self.findLeaves(l)
    return l

def findLeaves(self,l):
    if self.isLeaf():
        l.append(self.point)
        
    if self.l is not None: self.l.findLeaves(l)
    if self.r is not None: self.r.findLeaves(l)
\end{lstlisting}
\end{algorithm} 

\begin{algorithm}
\caption{Retorna uma lista com todos os pontos contidos numa dada janela \emph{rng}.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def query(self,rng):
    w1,w2 = rng
    div = self.findDividingNode(rng)
    p = []
        
    if div.isLeaf():
        if self.inRange(rng,div.point):
            p.append(div.point)
    else:
         v = div.l
         while(not v.isLeaf()):
             if w1 <= v.point:
                 subtree = v.r.listSubTree()
                 p += subtree
                 v = v.l
             else:
                 v = v.r
                    
\end{lstlisting}
\end{algorithm}
\newpage
\begin{algorithm}[H]
\ContinuedFloat
\caption{Continuação do algoritmo 7.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
         if self.inRange(rng,v.point):
             p.append(v.point)
         
         v = div.r
            
         while(not v.isLeaf()):
             if w2 > v.point:
                 subtree = v.l.listSubTree()
                 p += subtree
                 v = v.r
             else:
                 v = v.l
         if self.inRange(rng,v.point):
             p.append(v.point)

     return p
\end{lstlisting}
\end{algorithm} 
\subsection{Análise}

\begin{itemize}
\item[-] O pré-processamento requer que seja feita uma ordenação sobre o conjunto de pontos de entrada, portanto tem complexidade
  $\Theta(n\log n)$.
\item[-] A árvore terá altura $\mathcal{O}(\log n)$ e visitaremos $\mathcal{O}(\log n)$ pontos em cada subàrvore de $v_{div}$,
  além disso, consumiremos tempo $\mathcal{O}(k)$ para visitar os $k$ pontos das folhas que estão contidos no intervalo e devem
  aparecer na resposta final. Portanto a complexidade final da consulta é da ordem $\mathcal{O}(n\log n + k)$.
\end{itemize}
\newpage

\section{Janela limitada - Caso bidimensional}
\label{janela2d}
Analisaremos agora o problema no espaço do $\mathbb{R}^2$. Sejam $w_1 = (x_1,y_1)$ e $w_2 = (x_2,y_2)$ pontos no $\mathbb{R}^2$,
os segmentos de reta que formam um retângulo de lados paralelos ao eixos e que passam pelos pontos $w_1$ e $w_2$ são: $s_1
\coloneqq \overline{(x_1,y_1)(x_1,y_2)},~s_2 \coloneqq \overline{(x_1,y_2)(x_2,y_2)},~s_3 \coloneqq
\overline{(x_2,y_2)(x_2,y_1)}~\text{e}~s_4 \coloneqq \overline{(x_2,y_1)(x_1,y_1)}$, uma \textbf{janela} será definida como a
união desses 4 segmentos e sua região interna, porém, usaremos uma representação compacta representando a janela pelo segmento $s
\coloneqq \overline{w_1,w_2}$. Mostraremos primeiro o algoritmo mais simples que estende a ideia apresentada no algoritmo anterior
e no tópico seguinte uma estrutura de dado diferente que pode ser usada neste algoritmo para diminuir o consumo de tempo.

\subsection{Pré-processamento}

Precisaremos de uma estrutura de dados que consiga particionar o espaço de tal forma que consigamos saber a ordem entre os pontos
em cada semiplano. Uma estrutura que nos fornece isso é a chamada \textbf{árvore limite de 2 níveis}. A árvore limite é uma ABBB
cuja ordem dos elementos é feita sobre a coordenada $x$ e cada nó terá 4 elementos: um ponteiro para uma raíz de uma ABBB cujos
elementos são os mesmos da subárvore do nó com elementos ordenados pela coordenada $y$ (que seria o ``segundo nível'' da árvore),
um ponteiro para um ponto associado, um ponteiro para o filho esquerdo e um ponteiro para o filho direito.

Segue o algoritmo de construção dessa árvore. Omitiremos a implementação da estrutura auxiliar que utilizamos nesse trabalho com o
nome de \emph{VerticalTree} cuja descrição está presente no trabalho de \citet{junio09:MSc}, essa estrutura é uma ABBB construída
sobre um \emph{heap} e tem tempo de construção $\mathcal{O}(n)$. Ela será utilizada para fazermos consultas unidimensionais sobre
a coordenada $y$.

\begin{algorithm}[H]
  \caption{Retorna um ponteiro para uma raiz $v$ de uma ABBB ordenada pela coordenada $x$ a partir de um vetor de pontos ordenados
    por $x$ e um vetor de pontos ordenados por $y$.}  \lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def buildTree(self,vx,vy):
    v = Node(None)
    v.tree = VerticalTree(vy)
    lx = vx[:len(vx)//2]
    rx = vx[len(vx)//2:]
    n = len(vx)
    ly = []
    ry = []
        
    for i in range(n):
        if vy[i].x < vx[n//2-1].x or
        (vy[i].x == vx[n//2-1].x and
        vy[i].y <= vx[n//2-1].y):
            ly.append(vy[i])
        else: ry.append(vy[i])
\end{lstlisting}
\end{algorithm}
\newpage
\begin{algorithm}[H]
\ContinuedFloat
\caption{Continuação do algoritmo 8.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape] 
    v.point = vx[n//2-1]
        
    if len(vx) == 1:
        v.l = v.r = None
    else:
        v.l = self.buildTree(lx,ly)
        v.r = self.buildTree(rx,ry)

    return v
\end{lstlisting}
\end{algorithm}

\subsection{Realizando a consulta}
Seja $P$ um conjunto de pontos e seja $W = \overline{(x_1,y_1)(x_2,y_2)}$ uma janela. Podemos consultar todos os pontos em
$P \cap W$ da seguinte forma:

\begin{itemize}
\item[1.] Construímos a árvore limite sobre o conjunto $P$.
\item[2.] Achamos o \textbf{ponto divisor} no primeiro nível da árvore limite de forma similar ao algoritmo anterior.
\item[3.] Percorremos a subárvore esquerda de $v_{div}$ verificando se o ponto $r$ da raiz é tal que $w_1 \leq_{x} r$, caso seja,
  realizamos a consulta unidimensional na árvore associada ao nó. Caso contrário, caso contrário vamos para a subárvore
  direita. Ao chegar na folha apenas verificamos se $w_1 \leq_{x} r \leq_{x} w_2$ e adicionamos na resposta caso seja verdade.
\item[4.] Percorremos a subárvore direita de $v_{div}$ de forma simétrica ao item 3.
\end{itemize}

Segue a implementação das rotinas supracitadas juntamente com suas funções auxiliares:

\begin{algorithm}[H]
\caption{Verifica se o ponto $p$ está contido na janela \emph{rng}.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def inRange(self,rng,p):
    w1,w2 = rng
    a = w1.x < p.x or (w1.x == p.x and w1.y <= p.y)
    b = p.x < w2.x or (p.x == w2.x and p.y <= w2.y)
    c = w1.y < p.y or (w1.y == p.y and w1.x <= p.x)
    d = p.y < w2.y or (p.y == w2.y and p.x <= w2.x)
    return a and b and c and d
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[H]
  \caption{Retorna uma lista com todos os pontos contidos numa dada janela \emph{rng}.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def query(self,rng):
    p = []
    w1,w2 = rng
    div = self.findDividingNode(rng)

    if div.isLeaf():
        if self.inRange(rng,div.point):
            p.append(div.point)
    else:
        v = div.l

        while not v.isLeaf():
            if w1.x < v.point.x or
            (w1.x == v.point.x and w1.y <= v.point.y):
                p += v.r.tree.oneDimQuery(rng)
                v = v.l
            else:
                v = v.r

        if self.inRange(rng,v.point): p.append(v.point)

        v = div.r

        while not v.isLeaf():
            if w2.x > v.point.x:
                p += v.l.tree.oneDimQuery(rng)
                v = v.r
            else:
                v = v.l

        if self.inRange(rng,v.point): p.append(v.point)
                
    return p
\end{lstlisting}
\end{algorithm}

\subsection{Análise}
\begin{itemize}
\item[-] No pré-processamento ordenamos 2 vezes o conjunto de pontos, levando tempo $\mathcal{O}(n \log n)$. Como a construção da
  estrutura auxiliar leva tempo $\mathcal{O}(n)$, a construção da árvore levará também tempo $\mathcal{O}(n)$. O que nos leva à
  complexidade total de $\mathcal{O}(n \log n )$.
\item[-] Os caminhos esquerdo e direito a partir de $v_{div}$ têm $\mathcal{O}(\log n)$ nós, e possivelmente chamamos o algoritmo
  anterior para cada um deles, o que consome tempo $\mathcal{O}(\log n + k)$. O que nos leva ao consumo total de tempo de
  $\mathcal{O}(\log^2 n + k)$.
\end{itemize}

\section{Cascateamento fracionário}

Apresentaremos uma estrutura chamada \textbf{árvore limite com camadas} que utilizaremos no segundo nível do algoritmo acima para
conseguirmos complexidade total $\mathcal{O}(\log n + k)$, juntamente com a consulta modificada associada. A intuição dessa
técnica vem da seguinte característica das estruturas que vínhamos utilizando: Sempre ao acessarmos o filho de um dado nó passamos
a lidar com um subconjunto do conjunto que tínhamos na subárvore anterior e cujos elementos mantêm a mesma ordem relativa entre
si.

\subsection{Pré-processamento}

O primeiro nível da árvore limite com camadas será exatamente como mostrado anteriormente, a diferença estará presente no segundo nível onde teremos
uma estrutura que definimos como \textbf{árvore de camadas}. Os ``nós'' dessa árvore são na verdade vetores de nós auxiliares ordenados pelos pontos
associados.  \par Seja $P$ o conjunto de pontos associados a um dado vetor da árvore de camadas, sejam $V^x$ e $V^y$ vetores com os pontos de $P$
ordenados por $x$ e $y$ respectivamente, particionamos $V^y$ em 2 vetores: $V^y_e$ e $V^y_d$. Essa partição é feita da seguinte forma: Seja $v_{max}$
o maior ponto de $V^x$, seja $q \in V^y$, se $q \leq_x v_{max},~q \in V^y_e,~ \text{caso contrário}~q \in V^y_d$.  \par Portanto, seja $P$ o conjunto
de pontos associado ao vetor, seja $p \in P$ o ponto associado ao nó do vetor $V^y$, e sejam $V^y_e~\text{e}~V^y_d$ como definidos anteriormente, cada
elemento dos nós auxiliares terão os seguintes campos: Um ponteiro para o ponto $p$, um ponteiro $pt_{e}(q)$ para o menor ponto $q$ em $V^y_e$ tal que
$q \geq_y p$, um ponteiro $pt_{d}(u)$ para o menor ponto $u$ em $V^y_d$ tal que $u \geq_y p$, uma variável booleana que indica se o vetor ao qual o nó
pertence é $V^y_e$ ou $V^y_d$ e finalmente um ponteiro para o próximo elemento do vetor. Esse último ponteiro foi uma adaptação ao fato da linguagem
\emph{python} não apresentar aritmética de ponteiros, que foi utilizada na descrição desse algoritmo na dissertação de \citet{junio09:MSc}.

\begin{algorithm}[H]
  \caption{Retorna um ponteiro para um vetor ordenado de nós verticais a partir de um vetor de pontos ordenados por x e um vetor de
    pontos ordenados por y.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def buildTree(self,vx,vy):
    v = Node(None)
    lx = vx[:len(vx)//2]
    rx = vx[len(vx)//2:]
    n = len(vx)
    
    ly = []
    ry = []

    for i in range(n):
        if vy[i].point.x < vx[n//2-1].x or
        ((vy[i].point.x == vx[n//2-1].x) and
        vy[i].point.y <= vx[n//2-1].y):
            ly.append(LayerNode(vy[i].point))
        else:
            ry.append(LayerNode(vy[i].point))

    v.tree = self.createPointers(vy,ly,ry)
    v.point = vx[n//2-1]

    if n == 1:
        v.l = v.r = None
    else:
        for k in range(len(ly)-1): ly[k].nxt = ly[k+1]
                
        for k in range(len(ry)-1): ry[k].nxt = ry[k+1]
            
        v.l = self.buildTree(lx,ly)
        v.r = self.buildTree(rx,ry)

    return v
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[H]
  \caption{Preenche os ponteiros de um vetor $v$ de uma árvore de camadas a partir dos dois subvetores $l$ e $r$.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[]
def createPointers(self,v,l,r):
    il = 0
    ir = 0
    i = 0
    n = len(v)
    nl = len(l)
    nr = len(r)

    if n == 1:
        v[0].pl = v[0].pr = None
        return v

    while i < n:
        if il < nl:
            v[i].pl = l[il]
            l[il].side = False
        else:
            v[i].pl = None

        if ir < nr:
            v[i].pr = r[ir]
            r[ir].side = True
        else:
            v[i].pr = None

        if il < nl and v[i].point == l[il].point:
            il += 1
        else:
            ir += 1

        i += 1

    return v
\end{lstlisting}
\end{algorithm}

\subsection{Realizando a consulta}

Seja P um conjunto de pontos e seja $W = \overline{(x_1,y_1)(x_2,y_2)}$ uma janela. Podemos consultar todos os pontos em
$P \cap W$ da seguinte forma:

\begin{itemize}
\item[1.] Construímos a árvore limite com camadas sobre o conjunto $P$.
\item[2.] Achamos o \textbf{ponto divisor} no primeiro nível da árvore limite com camadas de forma similar ao algoritmo anterior.
\item[3.] Na árvore de camadas associada ao nó $v_{div}$ procuramos com uma busca binária o menor ponto
  $v'_{div} \colon v'_{div} \geq_y w_1$, conseguiremos pontos com a mesma característica nas subárvores de $v_{div}$ em tempo
  constante apenas utilizando os ponteiros auxiliares.
\item[4.] Percorremos a subárvore esquerda de $v_{div}$, seja $v$ um nó dessa subárvore e $v'$ o nó cujo ponto é o menor tal que
  $\geq_y w_1$ nessa subárvore. Caso $w_1 >_x p(v)$, continuamos a busca na subárvore direita de $v$ e acessamos o nó apontado por
  $pt_d(v')$ na árvore de camadas de $d(v)$. Se $w_1 \leq_x p(v)$, listamos todos os pontos $p \colon p \leq_y w_2$ da árvore de
  camadas de d(v) a partir do nó apontado por $pt_d(v')$. Retomamos a busca na subárvore esquerda de $v$ e acessamos o nó apontado
  por $pt_e(v's)$ na árvore de camadas de $e(v)$.
\item[5.] Simetricamente ao item 4, percorremos a subárvore direita de $v_{div}$.
\end{itemize}

Segue a consulta modificada referente à rotina acima:

\begin{algorithm}[H]
\caption{Retorna uma lista para todos os pontos contidos numa dada janela \emph{rng}.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def query(self,rng):
    p = []
    w1,w2 = rng
    div = self.findDividingNode(rng)
        
    if div.isLeaf():
        if self.inRange(rng,div.point):
            p.append(div.point)
    else:
        div2 = self.binarySearch(div.tree,w1) #menor ponto em div.tree >=_y que w1            
        if div2 is not None:
            v = div.l
            v2 = div2.pl

            while not v.isLeaf() and v2 is not None:
                if w1.x < v.point.x or
                ( w1.x == v.point.x and w1.y <= v.point.y ):
                    u = v2.pr                        
                    while u and u.side and
                    (u.point.y < w2.y or
                    ( u.point.y == w2.y and
                    u.point.x <= w2.x)):
                        p.append(u.point)
                        u = u.nxt
                        if u is None: break
                            
                    v = v.l
                    v2 = v2.pl
                else:
                    v = v.r
                    v2 = v2.pr
                        
            if v2 is not None and self.inRange(rng,v.point):
                p.append(v.point)
                    
\end{lstlisting}
\end{algorithm}


\begin{algorithm}[H]
\setalglineno{32}
\ContinuedFloat
\caption{Continuação do algoritmo 13.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
        if div2 is not None:
            v = div.r
            v2 = div2.pr

            while not v.isLeaf() and v2 is not None:
                if w2.x > v.point.x or
                (w2.x == v.point.x and
                w2.y >= v.point.y):
                    u = v2.pl

                    while not u.side and
                    (u.point.y < w2.y or
                    ( u.point.y == w2.y and
                    u.point.x <= w2.x)):
                        p.append(u.point)
                        u = u.nxt
                        if u is None: break
                        
                    v = v.r
                    v2 = v2.pr
                else:
                    v = v.l
                    v2 = v2.pl

            if v2 is not None and self.inRange(rng,v.point):
                p.append(v.point)
                    
    return p
\end{lstlisting}
\end{algorithm}

\subsection{Análise}

\begin{itemize}
\item[-] Precisamos inicialmente ordenar os pontos, o que leva $\mathcal{O}(n \log n)$. Criamos os ponteiros da árvore de camadas em $\mathcal{O}(n)$,
  portanto o algoritmo de construção leva $\mathcal{O}(n)$. Chegamos então no consumo total de $\mathcal{O}(n \log n)$.
\item[-] Achamos $v_{div}$ e $v'_{div}$ realizando buscas binárias, o que consome tempo $\mathcal{O}(\log n)$. Nas subárvores de $v_{div}$ levamos
  tempo proporcional ao número de pontos que se encontram na janela, nos dando complexidade $O(k)$. Portanto a complexidade final de tempo é
  $\mathcal{O}(\log n + k)$.
\end{itemize}
\newpage
\section{Janelas ilimitadas - caso unidimensional}

Seja $p$ um ponto na reta, definiremos uma janela ilimitada $W^{-}$ como o intervalo $(-\infty:p]$, definimos similarmente uma janela ilimitada $W^{+}$
como o intervalo $[p:\infty)$. A implementação desta seção resolve uma consulta sobre todos os pontos contidos numa janela $W^{-}$, mas a
implementação para uma janela $W^{+}$ é simétrica. Omitiremos a explicação da construção da estrutura que utilizaremos, pois trata-se de um
\emph{minheap} simples construído sobre o conjunto de pontos.


\subsection{Realizando a consulta}
\label{infwdwquery1d}
Seja $P$ um conjunto de pontos e $W^- \coloneqq (-\infty:w]$ uma janela ilimitada, podemos listar todos os pontos em $P \cap W^-$ da seguinte forma:


\begin{itemize}
\item[-] Olhamos para a raíz do heap, caso o ponto associado esteja à esquerda de $w$, listamos o ponto e repetimos a verificação para seus filhos
  esquerdo e direito.
\end{itemize}

\begin{algorithm}[H]
\caption{Retorna uma lista para todos os pontos em um \emph{minheap} v contidos numa dada janela ilimitada \emph{rng}.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def query(self, v, rng):
    l = []
    w = rng[1]
    if p is not None:
        if v.point <= w:
            l += v.point
            l += self.query(v.l,rng)
            l += self.query(v.r,rng)
    return l     
\end{lstlisting}
\end{algorithm}

\subsection{Análise}

\begin{itemize}
\item[-] Consumimos tempo $\mathcal{O}(1)$ por nó visitado que está na resposta. Portanto, chegamos à complexidade total de $\mathcal{O}(k)$.
\end{itemize}

\section{Janelas ilimitadas - caso bidimensional}

Sejam $w_1 = (x_1,y_1)$ e $w_2 = (x_2,y_2)$ pontos no $\mathbb{R}^2$, similarmente à seção \ref{janela2d} iremos definir 4 segmentos de reta que farão
parte da janela a ser consultada. Porém agora teremos uma pequena modificação: Seja $x_{min}$ o menor e seja $x_{max}$ o maior valor de $x$ do conjunto de
pontos, definimos arbitrariamente que ou $x_1 = x_{min} - 1$ ou $x_2 = x_{max} + 1$. Chamamos a janela construída com $x_1 = x_{min} - 1$ de $W^-$ e a
janela construída com $x_2 = x_{max} + 1$ de $W^+$. O algoritmo a seguir resolve um consulta sobre pontos numa janela $W^-$, mas é simétrico para uma
janela $W^+$ ou mesmo para janelas verticais. Na implementação faremos um certo abuso de linguagem permitido pela linguagem de programação escolhida:
definiremos $x_1 = -\infty$ e falaremos que $w_1 = (-\infty,y_1)$ é um ponto.

\subsection{Pré-processamento}

A estrutura de dados que utilizaremos para essa consulta é chamada de \textbf{árvore de busca em prioridade}, uma árvore de busca balanceada sobre a
coordenada $y$. Os nós da estrutura terão 4 campos: Um ponteiro para o ponto associado ao nó, um ponteiro para o filho esquerdo, um ponteiro para o
filho direito e um ponteiro para um ponto denominado $p_{min}$, através desse último ponteiro manteremos a propriedade de \emph{minheap}. Essa
estrutura será balanceada por construção, pois em cada nó pegamos o x-menor ponto $v_{min}$ do conjunto de pontos, em seguida atribuímos ao nó um
ponto $v$ tal que ao retirarmos $v$, os tamanhos das partições que serão usadas para construção dos filhos difiram em no máximo 1. Uma definição
adicional que será usada no algoritmo é: Dado um nó de uma árvore de busca em prioridade, caso o ponteiro para o filho direito desse nó seja nulo e o
ponteiro para o filho esquerdo seja não-nulo, chamaremos esse nó de \textbf{semi-folha}. Segue o código referente à essa implementação:

\begin{algorithm}[H]
\caption{Retorna um ponteiro para uma raíz de uma árvore de busca em prioridade a partir de 2 vetores ordenados.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def buildTree(self,vx,vy):
    v = minPrioritySearchNode(None)
    n = len(vx)

    if n > 0:
        ly = []; lx = []
        ry = []; rx = []
        d = 0
        v.pmin = vx[0]

        for i in range(ceil((n-1)/2)+d):
            if vy[i] != v.pmin: ly.append(vy[i])
        else: d+=1

        for i in range(ceil((n-1)/2)+d,n):
            if vy[i] != v.pmin: ry.append(vy[i])
                
        if n != 1: v.point = vy[ceil((n-1)/2)+d-1]

        for i in range(1,n):
            if vx[i].y < v.point.y or
            (vx[i].y == v.point.y and
            (vx[i].x <= v.point.x)): 
                lx.append(vx[i])
            else:
                rx.append(vx[i])
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[H]
\ContinuedFloat
\caption{Continuação do algoritmo 15.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]

        v.l = self.buildTree(lx,ly)
        v.r = self.buildTree(rx,ry)
    else:
        v = None

    return v
\end{lstlisting}
\end{algorithm}

\subsection{Realizando a consulta}

Seja P um conjunto de pontos e $W^-$ uma janela ilimitada, podemos consultar todos os pontos em $P \cap W^-$ da seguinte forma:

\begin{itemize}
\item[-] Começamos achando o nó divisor dessa árvore, a estrutura básica é similar à implementação anterior, porém agora verificamos se o nó checado não é um
  semi-folha e já adicionamos na resposta todos os \emph{pmin} dos nós acessados que estão dentro da janela na resposta final.
\item[-] Percorremos a subárvore esquerda de $v_{div}$ enquanto o nó atual não é uma folha ou semi-folha. Seja $v$ o nó que estamos verificando, se o
  ponto $pmin(v) <_y w_1$ adicionamos todas os pontos do \emph{minheap} da subárvore direita de $v$ na resposta e seguimos para a subárvore esquerda
  de $v$, caso contrário apenas seguimos para a subárvore direita de $v$.
\item[-] Seja $u$ o último nó verificado, caso $pmin(u)$ esteja na resposta adicionamos esse ponto na resposta. Caso $u$ seja uma semi-folha,
  verificamos se o $pmin(u.l)$ está na janela e o adicionamos na resposta.
\item[-] Repetimos o processo simetricamente para a subárvore direita de $v_{div}$.
\end{itemize}

Seguem os códigos que explicitam essa rotina:

\begin{algorithm}[H]
\caption{Retorna uma lista com todos os pontos de um \emph{minheap} $v$ que estão contidos numa dada janela \emph{rng}.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def pointsMinHeap(v,rng):
    p = []

    if v is not None:
        if self.inRange(rng,v.point):
            p.append(v.point)
            p += self.pointsMinHeap(v.l,rng)
            p += self.pointsMinHeap(v.r,rng)
    return p
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[H]
\caption{Devolve um ponteiro para o nó divisor de uma árvore de busca em prioridade e uma lista com pontos que estão dentro da janela dada
  \emph{rng}.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def findDividingNode(self,rng):
    p = []
    w1,w2 = rng
    div = self.root
        
    while (not div.isLeaf()) and
    (not div.isSemiLeaf()) and
    (w1.y > div.point.y and
     w2.y < div.point.y or
     (w2.y == div.point.y and
      ( w2.x <= div.point.x))) :
        if self.inRange(rng,div.pmin):
            p.append(div.pmin)
        if w2.y < div.point.y or
        (w2.y == div.point.y and
        (w2.x <= div.point.x)):
            div = div.l
        else:
            div = div.r

    return p, div
\end{lstlisting}
\end{algorithm}

\begin{algorithm}[H]
\caption{.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def query(self,rng):
    w1,w2 = rng

    p,div = self.findDividingNode(rng)

    if not div.isLeaf() and not div.isSemiLeaf():
        if self.inRange(rng,div.pmin):
            p.append(div.pmin)

        u = div.l

        while not u.isLeaf() and not u.isSemiLeaf():
            if self.inRange(rng,u.pmin):
                p.append(u.pmin)

            if w1.y < u.pmin.y or ( w1.y == u.pmin.y and
            (w1.x <= u.pmin.x)):
                p += self.pointsMinHeap(u.r,rng)
                u = u.l
            else:
                u = u.r

\end{lstlisting}
\end{algorithm}

\begin{algorithm}[H]
\ContinuedFloat
\caption{Continuação do algoritmo 17.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
        if self.inRange(rng,u.pmin):
            p.append(u.pmin)

        if u.isSemiLeaf():
            if self.inRange(rng,u.l.pmin):
                p.append(u.l.pmin)
                
        u = div.r

        while not u.isLeaf() and not u.isSemiLeaf():
            if self.inRange(rng,u.pmin):
                p.append(u.pmin)

            if u.pmin.y < w2.y or (u.pmin.y == w2.y and
            (u.pmin.x <= w2.x)):
                p += self.pointsMinHeap(u.l,rng)
                u = u.r
            else:
                u = u.l
                
        if self.inRange(rng,u.pmin):
            p.append(u.pmin)

        if u.isSemiLeaf():
            if self.inRange(rng,u.l.pmin):
                p.append(u.l.pmin)
            
    else:
        if self.inRange(rng,div.pmin):
            p.append(div.pmin)

        if div.isSemiLeaf():
            if self.inRange(rng,div.l.pmin):
                p.append(div.l.pmin)
    
    return p
\end{lstlisting}
\end{algorithm}
\newpage
\subsection{Análise}
\begin{itemize}
\item[-] Na construção, começamos ordenando os pontos da entrada, o que consome tempo $\mathcal{O}(n \log n)$. A construção em si é composta por partes
  $\theta(n)$ junto com duas chamadas recursivas para metade do tamanho, que consumirá por recorrência tempo $\mathcal{O}(n \log n)$. Chegamos
  portanto em consumo de tempo total de $\mathcal{O}(n \log n)$.
\item[-] A consulta seguirá por dois caminhos na árvore de tamanho $\log n$ cada, onde verificar se um dado pmin pertence à janela $W^-$ consome tempo
  $\mathcal{O}(1)$ e cada chamada de \emph{pointsMinHeap} consome tempo equivalente ao número de pontos da resposta contidos no heap, portando todas as
  chamadas totalizarão tempo $\mathcal{O}(k)$. Chegamos no total ao consumo de tempo de $\mathcal{O}(\log n + k)$.
\end{itemize}


%% ------------------------------------------------------------------------- %%

%% ------------------------------------------------------------------------- %%
\chapter{Consultas sobre segmentos em janelas}
\label{cap:segmentos}

Analisaremos nesse capítulo os algoritmos associados às consultas sobre conjuntos de segmentos no espaço. 

\section{Intervalos na reta}

Primeiramente explicaremos um algoritmo que resolve consultas no espaço $\mathbb{R}$. Definiremos a ``janela'' como um dado ponto no espaço e encontraremos todos os intervalos que contém esse ponto.

Na implementação usaremos intervalos como segmentos de reta, onde seus limites serão dados pelos campos $p_e$ e $p_d$ que denotam o ponto extremo
esquerdo e direito do segmento, respectivamente. Diremos que um dado conjunto $S = [s_1,s_2,\dots,s_n]$ de segmentos está $p_e$-ordenado caso
$p_e(s_1) \leq p_e(s_2) \leq \dots \leq p_e(s_n)$.

\subsection{Pré-processamento}

Armazenaremos os intervalos num tipo de árvore binária que chamaremos de \textbf{árvore de intervalos}. Cada nó dessa estrutura terá os seguintes
campos: Um ponteiro para um ponto associado, um ponteiro para o nó esquerdo, um ponteiro para o nó direito, um ponteiro para um \emph{minheap} de
segmentos $p_e$-ordenados (que chamaremos de $L_1$) e um ponteiro para um \emph{maxheap} de segmentos $p_d$-ordenados (que chamaremos de $L_2$).

Segue o código referente à construção dessa estrutura:

\begin{algorithm}[H]
\caption{Devolve um ponteiro para uma raíz $v$ de uma árvore de intervalos a partir de um vetor de intervalos ordenado.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def buildTree(self,s):
    n = len(s)
    if n > 0:
        v = IntervalNode()
        l = []
        r = []
        v.point = s[n//2].beg
        l1 = []
        l2 = []

        i = 0

\end{lstlisting}
\end{algorithm}

\begin{algorithm}[H]
\ContinuedFloat
\caption{Continuação do algoritmo 18.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
        while i < n and s[i].beg <= v.point:
            if s[i].end < v.point:
                l.append(s[i])
            else:
                l1.append(Point(s[i].beg.x,
                                s[i].beg.y,
                                s=s[i])
                l2.append(Point(s[i].end.x,
                                s[i].end.y,
                                s=s[i])
            i+=1

        v.L1 = buildMinHeap(l1)
        v.L2 = buildMaxHeap(l2)
        
        while i < n:
            r.append(s[i])
            i+=1
            
        v.l = self.buildTree(l)
        v.r = self.buildTree(r)

    else:
        v = None

    return v

\end{lstlisting}
\end{algorithm}


\subsection{Realizando a consulta}

Dado um ponto $w$ e um conjunto $S$ de segmentos, podemos consultar todos os segmentos de $S'= \{s \in S \colon s \ni w\}$ da seguinte forma:
Verificamos se o ponto associado ao nó está à esquerda do ponto $w$, caso esteja, adicionamos todos os segmentos que têm $p_e \leq w$, o que é
equivalente à fazer uma consulta de janela ilimitada da forma $W^- = (-\infty,w)$. Caso contrário, adicionamos todos os segmentos que têm $p_e \geq
w$, o que é equivalente à fazer uma consulta de janela ilimitada da forma $W^+ = (w,\infty)$.

Segue o algoritmo referente a esta rotina:


\begin{algorithm}[H]
\caption{Devolve uma lista de intervalos que contenham um dado ponto $p$.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def query(self,p):
    return self.query_r(self.root,p)

def query_r(self,v,p):
    l = []

    if v is not None:
        if p > v.point:
            aux = []
            rng = (p,Point(math.inf,0))
            aux = v.L2.maxheap_query(rng)
            for pnt in aux:
                l.append(pnt.seg)
            l += self.query_r(v.r,p)
        else:
            aux = []
            rng = (Point(-math.inf,0),p)
            aux = v.L1.minheap_query(rng)
            for pnt in aux:
                l.append(pnt.seg)
            l += self.query_r(v.l,p)
            
    return l
\end{lstlisting}
\end{algorithm}

(As chamadas das linhas 11 e 18 referem-se ao algoritmo descrito na seção \ref{infwdwquery1d})

\subsection{Análise}

\begin{itemize}
\item[-] Na construção da árvore, gastamos tempo inicial $\mathcal{O}(n \log n)$ para ordenar o conjunto de segmentos. Separar o
  conjunto de pontos em dois menores e construir os \emph{heaps} auxiliares leva tempo $\mathcal{O}(n)$. Chegaremos portanto no
  consumo total de tempo de $\mathcal{O}(n \log n)$.
\item[-] Pelo algoritmo de consulta, visitaremos $O(\log n)$ nós. Em cada nó realizamos algumas operações $\mathcal{O}(1)$, e seja
  $k'$ o número de pontos do heap que está contido na janela, uma consulta de tempo $O(k')$(O somatório de todos esses k's será
  k). Chegamos ao consumo total de tempo na consulta de $\mathcal{O}(\log n + k)$.
\end{itemize}
\newpage
\section{Consultas sobre segmentos horizontais e verticais}

O tipo de consulta que resolveremos nessa seção é o seguinte: Seja $S$ um conjunto de segmentos horizontais(ou verticais) não-intersectantes, e seja $w$ um segmento vertical(ou horizontal), queremos achar todos os segmentos de $S$ que intersectam $w$.

\subsection{Pré-processamento}

Utilizaremos uma estrutura que chamaremos de \textbf{árvore de intervalos horizontal}. Ela será idêntica à estrutura da seção bla,
com modificações nos ponteiros $L_1$, que agora aponta para uma árvore de busca em prioridade mínima, e $L_2$, que agora aponta
para uma árvore de busca em prioridade máxima.

Segue o seu algoritmo de construção:

\begin{algorithm}[H]
\caption{Devolve um ponteiro $v$ para uma raíz de uma árvore de intervalos horizontal a partir de um vetor $p_e$-ordenado $s$.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def buildTree(self,s):
    n = len(s)

    if n > 0:
        v = HorizontalIntervalNode()
        l = [] 
        r = []
        l1 = []
        l2 = []

        v.point = s[n//2].beg

        i = 0

        while i < n and s[i].beg <= v.point:
            if s[i].end < v.point:
                l.append(s[i])
            else:
                l1.append(s[i])
                l2.append(s[i])
            i+=1

        while i < n:
            r.append(s[i])
            i+=1

        aux = []
        for s in l1:
            aux.append(Point(s.beg.x,s.beg.y,s))

\end{lstlisting}
\end{algorithm}

\begin{algorithm}[H]
\ContinuedFloat
\caption{Continuação do algoritmo 21.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
        v.L1 = minPrioritySearchTree(aux)

        aux = []

        for s in l2:
            aux.append(Point(s.end.x,s.end.y,s))

        v.L2 = maxPrioritySearchTree(aux)

        v.l = self.buildTree(l)
        v.r = self.buildTree(r)

    else:
        v = None

    return v
\end{lstlisting}
\end{algorithm}

\subsection{Realizando a consulta}

Seja $S$ um conjunto de segmentos horizontais não-intersectantes, e seja $w = \overline{(x,y),(x,y')}$ um segmento vertical,
podemos encontrar todos os segmentos $S' \coloneqq \{ s \in S \colon s \cap w \ne 0\}$ da seguinte forma: Seja $v$ o nó que estamos
olhando atualmente, caso $x > x(p(v))$ nenhum segmento que esteja armazenado à esquerda de $v$ pode interceptar $w$, por isso
seguiremos para $d(v)$. Mas antes disso fazemos uma consulta por todos os pontos finais de segmentos que se encontram à direita do
segmento $w$, que é equivalente a realizar uma consulta na estrutura $L_2$ com uma janela $\overline{(x,y),(\infty,y')}$. Caso $x <
x(p(v))$, fazemos uma busca em $L_1$ com janela $\overline{(-\infty,y),(x,y')}$ e seguimos para $e(v)$, simetricamente ao que foi feito
no outro caso.

Segue o algoritmo referente a essa rotina:

\begin{algorithm}[H]
\caption{Retorna um lista de segmentos horizontais não-intersectantes que intersectam um dado segmento \emph{seg}.}
\lstset{basicstyle=\ttfamily\color{text}\bfseries}
\begin{lstlisting}[mathescape]
def query(self,seg):
    return self.query_r(self.root,seg)

def query_r(self,v,seg):
    l = []
    w1,w2 = seg
    x = w1.x
    y = w1.y
    y2 = w2.y

    if v is not None:
        if x > v.point.x:
            rng = (Point(x,y),Point(inf,y2))
            l = v.L2.query(rng)
            l += self.query_r(v.r,seg)
        else:
            rng = (Point(-inf,y),Point(x,y2))
            l = v.L1.query(rng)
            l += self.query_r(v.l,seg)

    return l

\end{lstlisting}
\end{algorithm}


\subsection{Análise}

\begin{itemize}
\item[-] Na construção, inicialmente $p_e$-ordenamos o vetor de segmentos, consumindo tempo $\mathcal{O}(n \log n)$. Na construção
  em si, particionamos um vetor em 2 e preenchemos 2 vetores auxiliares, todas operações $\mathcal{O}(n)$. Além disso, construímos
  2 árvores de busca em prioridade, que como vimos anteriormente tem complexidade $\mathcal{O}(n_v \log n_v)$, somando-se todas as
  chamadas que serão feitas à essas funções, teremos também complexidade $\mathcal{O}(n \log n)$. As chamadas para os filhos
  esquerdo e direito com vetores aproximadamente com a metade de elementos de $v$ resulta num recorrência cuja resolução nos
  mostra que a complexidade total da construção da árvore será $\mathcal{O}(n \log n)$.
\item[-] Visitaremos um nó por nível da árvore, portanto visitaremos $\mathcal{O}(\log n)$ nós. Em cada nó realizamos algumas
  operações $\mathcal{O}(1)$ e uma busca numa árvore de busca em prioridade, consumindo tempo $\mathcal{O}(\log n' + k') =
  \mathcal{O}(\log n + k')$, onde $n'$ é o número de elementos armazenados na árvore e $k'$ o número de elementos da árvore que
  intersectam o segmento $w$ ($\sum k' = k$). Assim, chegamos ao consumo total de tempo de consulta de $\mathcal{O}(\log^2 n + k)$.
\end{itemize}

\section{Consultas sobre segmentos em janelas}

\subsection{Pré-processamento}
\subsection{Realizando a consulta}
\subsection{Análise}

%% ------------------------------------------------------------------------- %%


% cabeçalho para os apêndices
\renewcommand{\chaptermark}[1]{\markboth{\MakeUppercase{\appendixname\ \thechapter}} {\MakeUppercase{#1}} } \fancyhead[RE,LO]{}
%\appendix

%\include{ape-exemplo}      % associado ao arquivo: 'ape-conjuntos.tex'


% ---------------------------------------------------------------------------- %
% Bibliografia
\backmatter \singlespacing   % espaçamento simples
\bibliographystyle{plainnat-ime} % citação bibliográfica textual
\bibliography{bibliografia}  % associado ao arquivo: 'bibliografia.bib'


%%%  ---------------------------------------------------------------------------- %
%% % Índice remissivo
%% \index{TBP|see{periodicidade região codificante}}
%% \index{DSP|see{processamento digital de sinais}}
%% \index{STFT|see{transformada de Fourier de tempo reduzido}}
%% \index{DFT|see{transformada discreta de Fourier}}
%% \index{Fourier!transformada|see{transformada de Fourier}}

%% \printindex   % imprime o índice remissivo no documento 

\end{document}
